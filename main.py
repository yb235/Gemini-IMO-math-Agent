# @title LangGraph Code for the IMO Multi-Agent Workflow
# @markdown This script requires the following packages to be installed:
# @markdown `pip install langchain langgraph langchain-google-genai python-dotenv`


import os
from typing import List, TypedDict, Optional
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import ChatPromptTemplate
from pydantic import BaseModel, Field
from langgraph.graph import StateGraph, END

# --- 1. Environment Setup ---
# Load API keys from .env file (optional, for local development)
from dotenv import load_dotenv
import pathlib

# Try to load .env file with explicit path
env_path = pathlib.Path(__file__).parent / '.env'
loaded = load_dotenv(env_path)
print(f"Debug: .env file exists at {env_path}: {env_path.exists()}")
print(f"Debug: load_dotenv returned: {loaded}")

# Check for API key and prompt if not found
api_key = os.getenv("GOOGLE_API_KEY")
print(f"Debug: API key found: {'Yes' if api_key else 'No'}")

if not api_key:
    print("Google API Key not found in environment variables.")
    print(f"Please add GOOGLE_API_KEY=your_key to: {env_path}")
    print("Make sure to remove the # comment character!")
    api_key = input("Please enter your Google API key: ").strip()
    if api_key:
        os.environ["GOOGLE_API_KEY"] = api_key
    else:
        print("No API key provided. Exiting.")
        exit(1)

# --- 2. Define the State for the Graph ---
# The state is the shared memory that each node in the graph can access and modify.
class GraphState(TypedDict):
    """
    Represents the state of our multi-agent workflow.

    Attributes:
        problem_statement: The initial mathematical problem to solve.
        solution: The current proposed solution.
        bug_report: A report from the verifier detailing issues.
        verification_summary: The final verdict from the verifier.
        iterations: The number of correction loops.
        error: A field to capture any processing errors.
    """
    problem_statement: str
    solution: Optional[str] = None
    bug_report: Optional[str] = None
    verification_summary: Optional[str] = None
    iterations: int = 0
    error: Optional[str] = None

# --- 3. Define Pydantic Models for Structured Output ---
# These models ensure the LLM's output is in a specific, parsable format.

class SolutionSummary(BaseModel):
    """The high-level summary of a proposed mathematical solution."""
    verdict: str = Field(description="State clearly whether you have found a complete solution or a partial solution.")
    method_sketch: str = Field(description="A high-level, conceptual outline of your solution strategy.")

class DetailedSolution(BaseModel):
    """The detailed, step-by-step mathematical proof."""
    proof: str = Field(description="The full, step-by-step mathematical proof, presented cleanly in TeX format.")

class SolutionGeneration(BaseModel):
    """The complete output for the generator agent."""
    summary: SolutionSummary
    detailed_solution: DetailedSolution

class BugReport(BaseModel):
    """A structured report of issues found in a mathematical solution."""
    final_verdict: str = Field(description="A single, clear sentence declaring the overall validity of the solution (e.g., 'The solution is correct', 'The solution contains a Critical Error').")
    findings: List[str] = Field(description="A list summarizing every issue discovered, including its location and classification (Critical Error or Justification Gap).")

# --- 4. Model Selection and Initialization ---
# Let user choose the Gemini model
print("\nü§ñ MODEL SELECTION")
print("=" * 50)
print("Please select the Gemini model you would like to use:")
print("1. Gemini 2.0 Flash - Faster responses, good for general tasks")
print("2. Gemini Pro - More capable reasoning, better for complex mathematics")
print("=" * 50)

while True:
    model_choice = input("Enter your choice (1 or 2): ").strip()
    if model_choice == "1":
        selected_model = "gemini-2.0-flash-exp"
        print("‚úÖ Selected: Gemini 2.0 Flash")
        break
    elif model_choice == "2":
        selected_model = "gemini-2.5-pro"
        print("‚úÖ Selected: Gemini 2.5 Pro")
        break
    else:
        print("‚ùå Invalid choice. Please enter 1 or 2.")

# Initialize the Language Model with selected model
# Following the paper specifications: temperature 0.1 for consistent responses
print(f"\nüîÑ Initializing {selected_model}...")
llm = ChatGoogleGenerativeAI(
    model=selected_model,
    temperature=0.1,  # Low temperature as specified in paper Section 3
    max_output_tokens=8192  # Reduced token limit to prevent timeouts
)

# Test the API connection with the selected model
print("üß™ Testing API connection...")
try:
    test_response = llm.invoke("Test connection")
    print("‚úÖ API connection successful!")
    print(f"üì° Model: {selected_model}")
    print(f"üîó Connection: Active")
except Exception as e:
    print(f"‚ùå API connection failed!")
    print(f"üö® Error: {str(e)}")
    print(f"üí° Suggestions:")
    print(f"   ‚Ä¢ Check your GOOGLE_API_KEY is valid")
    print(f"   ‚Ä¢ Verify the model '{selected_model}' is available in your region")
    print(f"   ‚Ä¢ Try switching to the other model option")
    print(f"   ‚Ä¢ Check your internet connection")
    print("\nüõë Exiting due to API connection failure.")
    exit(1)

# --- 5. Define the Agent Nodes ---
# Each node is a function that performs a specific task in the workflow.

def generator_node(state: GraphState):
    """
    Node for Step 1: Initial Solution Generation.
    Generates an initial solution based on the problem statement.
    """
    print("=" * 60)
    print("üß† GENERATOR AGENT - MATHEMATICAL PROBLEM SOLVER")
    print("=" * 60)
    print(f"üìã TASK: Solve the mathematical problem")
    print(f"üìù PROBLEM: {state['problem_statement']}")
    print("\nü§î THINKING PROCESS:")
    print("‚Ä¢ Analyzing the problem structure and requirements")
    print("‚Ä¢ Determining the most appropriate mathematical approach")
    print("‚Ä¢ Formulating a step-by-step solution strategy")
    print("‚Ä¢ Preparing rigorous mathematical proof")
    print("\n‚öôÔ∏è  PROCESSING... (Calling Gemini 2.5 Pro)")
    
    # Step 1 Prompt from Section 3.1 of the research paper
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", """### Core Instructions ###

**Rigor is Paramount:** Your primary goal is to produce a complete and rigorously justified solution. Every step in your solution must be logically sound and clearly explained. A correct final answer derived from flawed or incomplete reasoning is considered a failure.

**Honesty About Completeness:** If you cannot find a complete solution, you must **not** guess or create a solution that appears correct but contains hidden flaws or justification gaps. Instead, you should present only significant partial results that you can rigorously prove. A partial result is considered significant if it represents a substantial advancement toward a full solution. Examples include:
‚Ä¢ Proving a key lemma.
‚Ä¢ Fully resolving one or more cases within a logically sound case-based proof.
‚Ä¢ Establishing a critical property of the mathematical objects in the problem.
‚Ä¢ For an optimization problem, proving an upper or lower bound without proving that this bound is achievable.

**Use TeX for All Mathematics:** All mathematical variables, expressions, and relations must be enclosed in TeX delimiters (e.g., 'Let $n$ be an integer.').

### Output Format ###
Your response MUST be structured into the following sections, in this exact order.

**1. Summary**
Provide a concise overview of your findings. This section must contain two parts:
**a. Verdict:** State clearly whether you have found a complete solution or a partial solution.
‚Ä¢ **For a complete solution:** State the final answer, e.g., "I have successfully solved the problem. The final answer is..."
‚Ä¢ **For a partial solution:** State the main rigorous conclusion(s) you were able to prove, e.g., "I have not found a complete solution, but I have rigorously proven that..."

**b. Method Sketch:** Present a high-level, conceptual outline of your solution. This sketch should allow an expert to understand the logical flow of your argument without reading the full detail. It should include:
‚Ä¢ A narrative of your overall strategy.
‚Ä¢ The full and precise mathematical statements of any key lemmas or major intermediate results.
‚Ä¢ If applicable, describe any key constructions or case splits that form the backbone of your argument.

**2. Detailed Solution**
Present the full, step-by-step mathematical proof. Each step must be logically justified and clearly explained. The level of detail should be sufficient for an expert to verify the correctness of your reasoning without needing to fill in any gaps. This section must contain ONLY the complete, rigorous proof, free of any internal commentary, alternative approaches, or failed attempts.

### Self-Correction Instruction ###
Before finalizing your output, carefully review your "Method Sketch" and "Detailed Solution" to ensure they are clean, rigorous, and strictly adhere to all instructions provided above. Verify that every statement contributes directly to the final, coherent mathematical argument."""),
            ("user", "Problem: {problem}\n\nSolve this International Mathematical Olympiad problem following the exact format specified above."),
        ]
    )

    # Use the.with_structured_output method to get a guaranteed JSON-like object.
    structured_llm = llm.with_structured_output(SolutionGeneration)
    chain = prompt | structured_llm

    try:
        print("üîÑ Making API call to Gemini...")
        response = chain.invoke({"problem": state["problem_statement"]})
        print("‚úÖ API call completed successfully")
        solution_text = f"## Summary\n\n**Verdict:** {response.summary.verdict}\n\n**Method Sketch:**\n{response.summary.method_sketch}\n\n## Detailed Solution\n\n{response.detailed_solution.proof}"
        
        print("\n‚úÖ GENERATOR OUTPUT:")
        print("=" * 40)
        print(f"üìä VERDICT: {response.summary.verdict}")
        print(f"üéØ METHOD SKETCH:")
        print(f"   {response.summary.method_sketch}")
        print(f"üìù DETAILED PROOF:")
        print(f"   {response.detailed_solution.proof}")
        print("=" * 40)
        print("‚úÖ Generator completed successfully - passing solution to Verifier")
        
        return {"solution": solution_text}
    except Exception as e:
        print(f"‚ùå ERROR IN GENERATOR: {e}")
        print("üö® Generator failed - terminating workflow")
        print("üí° Possible causes:")
        print(f"   ‚Ä¢ API rate limit exceeded")
        print(f"   ‚Ä¢ Network connectivity issues") 
        print(f"   ‚Ä¢ Model '{selected_model}' temporarily unavailable")
        print(f"   ‚Ä¢ Invalid API key or permissions")
        return {"error": f"Failed to generate a solution: {str(e)}"}

def self_improvement_node(state: GraphState):
    """
    Node for Step 2: Self-Improvement.
    The model reviews and tries to improve its initial solution.
    This step injects additional thinking budget as mentioned in the paper.
    """
    print("\n" + "=" * 60)
    print("üîÑ SELF-IMPROVEMENT AGENT - SOLUTION REFINER")
    print("=" * 60)
    print(f"üìã TASK: Review and improve the initial solution")
    print(f"üìù RECEIVED FROM: Generator Agent")
    print(f"üí≠ PURPOSE: Inject additional thinking budget (32768 tokens)")
    print("\nü§î THINKING PROCESS:")
    print("‚Ä¢ Reviewing the initial solution for potential improvements")
    print("‚Ä¢ Identifying areas that could be made more rigorous")
    print("‚Ä¢ Expanding on abbreviated reasoning steps")
    print("‚Ä¢ Ensuring mathematical completeness and clarity")
    print("‚Ä¢ Using additional thinking budget to refine the approach")
    print("\n‚öôÔ∏è  PROCESSING... (Calling Gemini 2.5 Pro for self-improvement)")
    
    # Step 2 Self-Improvement Prompt
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", """You are a world-class mathematician reviewing your own initial solution to an IMO problem. Your task is to critically examine and improve your work.

### Core Instructions ###

**Critical Self-Review:** Carefully examine your initial solution. Look for:
‚Ä¢ Areas where reasoning could be made more rigorous
‚Ä¢ Steps that could be expanded or better justified  
‚Ä¢ Potential gaps in logic or missing details
‚Ä¢ Opportunities to strengthen the mathematical argument
‚Ä¢ Ways to make the presentation clearer and more complete

**Improvement Focus:** Your goal is to produce an enhanced version that:
‚Ä¢ Maintains the core approach if it's sound
‚Ä¢ Fills in any gaps or missing justifications
‚Ä¢ Expands abbreviated reasoning steps
‚Ä¢ Ensures every claim is properly supported
‚Ä¢ Uses clearer mathematical exposition

**Output Format:** Follow the same structured format as your initial solution:
1. **Summary** (with verdict and method sketch)
2. **Detailed Solution** (the improved, step-by-step proof)

**Self-Correction:** Use your additional thinking budget to thoroughly work through the problem again, building upon your initial insights while addressing any weaknesses."""),
            ("user", """### Original Problem ###
{problem}

### Your Initial Solution ###
{solution}

### Self-Improvement Task ###
Review your initial solution above and provide an improved version. Focus on enhancing rigor, filling gaps, and strengthening the mathematical argument while maintaining the core approach if it's sound."""),
        ]
    )

    structured_llm = llm.with_structured_output(SolutionGeneration)
    chain = prompt | structured_llm

    try:
        response = chain.invoke({
            "problem": state["problem_statement"],
            "solution": state["solution"]
        })
        improved_solution = f"## Summary\n\n**Verdict:** {response.summary.verdict}\n\n**Method Sketch:**\n{response.summary.method_sketch}\n\n## Detailed Solution\n\n{response.detailed_solution.proof}"
        
        print("\nüìã SELF-IMPROVEMENT OUTPUT:")
        print("=" * 40)
        print("‚úÖ IMPROVEMENT STATUS: SOLUTION REFINED")
        print(f"üìä REFINED VERDICT: {response.summary.verdict}")
        print(f"üéØ ENHANCED METHOD SKETCH:")
        print(f"   {response.summary.method_sketch}")
        print(f"üìù IMPROVED PROOF:")
        print(f"   {response.detailed_solution.proof}")
        print("=" * 40)
        print("‚úÖ Self-improvement completed - passing enhanced solution to Verifier")
        
        return {"solution": improved_solution}
    except Exception as e:
        print(f"‚ùå ERROR IN SELF-IMPROVEMENT: {e}")
        print("üö® Self-improvement failed - using original solution")
        print("üí° Possible causes:")
        print(f"   ‚Ä¢ API rate limit exceeded")
        print(f"   ‚Ä¢ Model '{selected_model}' temporarily unavailable")
        print(f"   ‚Ä¢ Network connectivity issues")
        return {}  # Keep original solution if improvement fails

def verifier_node(state: GraphState):
    """ 
    Node for Step 3: Verifying the Solution.
    Checks the solution for errors and generates a structured bug report.
    """
    print("\n" + "=" * 60)
    print("üîç VERIFIER AGENT - MATHEMATICAL SOLUTION VALIDATOR")
    print("=" * 60)
    print(f"üìã TASK: Critically examine the proposed solution")
    print(f"üîé CURRENT ITERATION: {state.get('iterations', 0) + 1}")
    print(f"üìù REVIEWING SOLUTION FROM: Generator Agent")
    print("\nü§î THINKING PROCESS:")
    print("‚Ä¢ Reading and understanding the original problem")
    print("‚Ä¢ Analyzing the proposed solution step-by-step")
    print("‚Ä¢ Checking mathematical logic and calculations")
    print("‚Ä¢ Identifying gaps in reasoning or critical errors")
    print("‚Ä¢ Classifying issues as 'Critical Error' or 'Justification Gap'")
    print("\n‚öôÔ∏è  PROCESSING... (Calling Gemini 2.5 Pro for verification)")
    
    # Step 3 Verification Prompt from Section 3.2 of the research paper
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", """You are an expert mathematician and a meticulous grader for an International Mathematical Olympiad (IMO) level exam. Your primary task is to rigorously verify the provided mathematical solution. A solution is to be judged correct **only if every step is rigorously justified.** A solution that arrives at a correct final answer through flawed reasoning, educated guesses, or with gaps in its arguments must be flagged as incorrect or incomplete.

### Instructions ###

**1. Core Instructions**
‚Ä¢ Your sole task is to find and report all issues in the provided solution. You must act as a **verifier**, NOT a solver. **Do NOT attempt to correct the errors or fill the gaps you find.**
‚Ä¢ You must perform a **step-by-step** check of the entire solution. This analysis will be presented in a **Detailed Verification Log**, where you justify your assessment of each step: for correct steps, a brief justification suffices; for steps with errors or gaps, you must provide a detailed explanation.

**2. How to Handle Issues in the Solution**
When you identify an issue in a step, you MUST first classify it into one of the following two categories and then follow the specified procedure.

**a. Critical Error:**
This is any error that breaks the logical chain of the proof. This includes both **logical fallacies** (e.g., claiming that 'A>B, C>D' implies 'A-C>B-D') and **factual errors** (e.g., a calculation error like '2+3=6').

**Procedure:**
‚Ä¢ Explain the specific error and state that it **invalidates the current line of reasoning**.
‚Ä¢ Do NOT check any further steps that rely on this error.
‚Ä¢ You MUST, however, scan the rest of the solution to identify and verify any fully independent parts. For example, if a proof is split into multiple cases, an error in one case does not prevent you from checking the other cases.

**b. Justification Gap:**
This is for steps where the conclusion may be correct, but the provided argument is incomplete, hand-wavy, or lacks sufficient rigor.

**Procedure:**
‚Ä¢ Explain the gap in the justification.
‚Ä¢ State that you will **assume the step's conclusion is true** for the sake of argument.
‚Ä¢ Then, proceed to verify all subsequent steps to check if the remainder of the argument is sound.

**3. Output Format**
Your response MUST be structured into two main sections: a **Summary** followed by the **Detailed Verification Log**.

**a. Summary**
This section MUST be at the very beginning of your response. It must contain two components:
‚Ä¢ **Final Verdict**: A single, clear sentence declaring the overall validity of the solution. For example: "The solution is correct," "The solution contains a Critical Error and is therefore invalid," or "The solution's approach is viable but contains several Justification Gaps."
‚Ä¢ **List of Findings**: A bulleted list that summarizes **every** issue you discovered. For each finding, you must provide:
  ‚Ä¢ **Location:** A direct quote of the key phrase or equation where the issue occurs.
  ‚Ä¢ **Issue:** A brief description of the problem and its classification (**Critical Error** or **Justification Gap**).

**b. Detailed Verification Log**
Following the summary, provide the full, step-by-step verification log as defined in the Core Instructions. When you refer to a specific part of the solution, **quote the relevant text** to make your reference clear before providing your detailed analysis of that part."""),
            ("user", """### Problem ###
{problem}

### Solution ###
{solution}

### Verification Task Reminder ###
Your task is to act as an IMO grader. Now, generate the **summary** and the **step-by-step verification log** for the solution above. In your log, justify each correct step and explain in detail any errors or justification gaps you find, as specified in the instructions above."""),
        ]
    )

    # Try structured output first, fallback to regular output if it fails
    try:
        structured_llm = llm.with_structured_output(BugReport)
        chain = prompt | structured_llm
        print("üîÑ Attempting structured verification...")
        response = chain.invoke({
            "problem": state["problem_statement"],
            "solution": state["solution"]
        })
        print("‚úÖ Structured verification completed")
        
        # Defensively ensure findings is a list, even if the LLM returns None.
        findings = response.findings or []
        final_verdict = response.final_verdict
        
    except Exception as struct_error:
        print(f"‚ö†Ô∏è  Structured output failed: {struct_error}")
        print("üîÑ Falling back to regular LLM output...")
        
        # Fallback to regular LLM call
        regular_chain = prompt | llm
        raw_response = regular_chain.invoke({
            "problem": state["problem_statement"],
            "solution": state["solution"]
        })
        
        response_text = raw_response.content if hasattr(raw_response, 'content') else str(raw_response)
        print(f"üìù Raw verifier response: {response_text[:200]}...")
        
        # Simple parsing of response
        if "the solution is correct" in response_text.lower():
            findings = []
            final_verdict = "The solution is correct."
        else:
            findings = ["Verification completed with regular output - see detailed response above"]
            final_verdict = "The solution may contain issues - manual review recommended."

    print("\nüìã VERIFIER OUTPUT:")
    print("=" * 40)
    
    if not findings:
        summary = final_verdict
        report = "No issues found."
        print("‚úÖ VERIFICATION STATUS: SOLUTION ACCEPTED")
        print(f"üìä FINAL VERDICT: {summary}")
        print("üéâ No mathematical errors or gaps found!")
        print("‚úÖ Verifier completed - Solution is ready for final output")
    else:
        summary = final_verdict
        report = "\n".join(f"- {finding}" for finding in findings)
        print("‚ùå VERIFICATION STATUS: ISSUES FOUND")
        print(f"üìä FINAL VERDICT: {summary}")
        print("üîç DETAILED FINDINGS:")
        for i, finding in enumerate(findings, 1):
            print(f"   {i}. {finding}")
        print("‚ö†Ô∏è  Verifier completed - Solution needs correction")
    
    print("=" * 40)

    return {
        "verification_summary": summary,
        "bug_report": report,
        "iterations": state.get("iterations", 0) + 1
    }

def human_review_node(state: GraphState):
    """
    Node for Step 4: Human Review of the Bug Report.
    This simulates the human-in-the-loop step.
    """
    print("\n" + "=" * 60)
    print("üë§ HUMAN REVIEW AGENT - QUALITY ASSURANCE GATE")
    print("=" * 60)
    print(f"üìã TASK: Review verifier's findings before correction")
    print(f"üîé ITERATION: {state.get('iterations', 1)}")
    print(f"üì• RECEIVED FROM: Verifier Agent")
    print(f"üì§ DECISION WILL GO TO: Corrector Agent (if approved)")
    
    print("\nü§î YOUR ROLE:")
    print("‚Ä¢ Evaluate whether the verifier's bug report is accurate")
    print("‚Ä¢ Decide if the identified issues warrant correction")
    print("‚Ä¢ Ensure the correction process should proceed")
    print("‚Ä¢ Act as a quality gate in the workflow")
    
    print("\nüìã VERIFICATION SUMMARY:")
    print("=" * 40)
    print(f"üìä STATUS: {state['verification_summary']}")
    print("\nüîç DETAILED BUG REPORT:")
    print("=" * 40)
    bug_lines = state["bug_report"].split('\n')
    for i, line in enumerate(bug_lines, 1):
        if line.strip():
            print(f"   {i}. {line.strip()}")
    print("=" * 40)
    
    print("\nüéØ DECISION REQUIRED:")
    print("Do you agree with the verifier's assessment?")
    print("‚Ä¢ Type 'y' to APPROVE the bug report and proceed with correction")
    print("‚Ä¢ Type 'n' to REJECT the bug report and end the workflow")

    # In a real application, this could be an API endpoint or a UI.
    # Here, we simulate it with a command-line input.
    while True:
        user_input = input("\nüë§ Your decision (y/n): ").lower()
        if user_input == 'y':
            print("\n‚úÖ HUMAN DECISION: Bug report APPROVED")
            print("üì§ Passing control to Corrector Agent...")
            return {} # No state change needed, just proceed
        elif user_input == 'n':
            print("\n‚ùå HUMAN DECISION: Bug report REJECTED")
            print("üõë Workflow terminated by human reviewer")
            return {"error": "Human reviewer rejected the bug report."}

def corrector_node(state: GraphState):
    """
    Node for Step 5: Correcting the Solution.
    Improves the solution based on the verifier's bug report.
    """
    print("\n" + "=" * 60)
    print("üîß CORRECTOR AGENT - MATHEMATICAL SOLUTION REFINER")
    print("=" * 60)
    print(f"üìã TASK: Fix the solution based on verification feedback")
    print(f"üîÑ CORRECTION ITERATION: {state.get('iterations', 1)}")
    print(f"üì• RECEIVED FEEDBACK FROM: Verifier Agent (via Human Review)")
    print(f"üìù ORIGINAL PROBLEM: {state['problem_statement']}")
    print("\nü§î THINKING PROCESS:")
    print("‚Ä¢ Analyzing the verifier's bug report and identified issues")
    print("‚Ä¢ Understanding what went wrong in the original solution")
    print("‚Ä¢ Developing a corrected approach to address each issue")
    print("‚Ä¢ Ensuring the new solution is mathematically rigorous")
    print("‚Ä¢ Maintaining clarity while fixing identified problems")
    print(f"\nüîç ISSUES TO ADDRESS:")
    bug_lines = state['bug_report'].split('\n')
    for i, line in enumerate(bug_lines[:5], 1):  # Show first 5 issues
        if line.strip():
            print(f"   {i}. {line.strip()}")
    print("\n‚öôÔ∏è  PROCESSING... (Calling Gemini 2.5 Pro for correction)")
    
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", "You are a world-class mathematician, capable of solving the hardest problems from the International Mathematical Olympiad (IMO). You have received a bug report for your previous solution. Your task is to revise and improve the solution based on the feedback provided in the bug report. Ensure the corrected solution is rigorous, complete, and addresses all identified issues."),
            ("user", "Problem: {problem}\n\nOriginal Solution: {solution}\n\nBug Report: {bug_report}\n\nBased on the bug report, provide a fully revised and corrected solution. This includes a high-level summary (verdict and method sketch) and a new detailed proof."),
        ] 
    )

    # Use structured output for consistency with the generator.
    structured_llm = llm.with_structured_output(SolutionGeneration)
    chain = prompt | structured_llm

    try:
        response = chain.invoke({
            "problem": state["problem_statement"],
            "solution": state["solution"],
            "bug_report": state["bug_report"]
        })
        solution_text = f"## Summary\n\n**Verdict:** {response.summary.verdict}\n\n**Method Sketch:**\n{response.summary.method_sketch}\n\n## Detailed Solution\n\n{response.detailed_solution.proof}"
        
        print("\nüìã CORRECTOR OUTPUT:")
        print("=" * 40)
        print("‚úÖ CORRECTION STATUS: SOLUTION REVISED")
        print(f"üìä NEW VERDICT: {response.summary.verdict}")
        print(f"üéØ UPDATED METHOD SKETCH:")
        print(f"   {response.summary.method_sketch}")
        print(f"üìù REVISED PROOF:")
        print(f"   {response.detailed_solution.proof}")
        print("=" * 40)
        print("‚úÖ Corrector completed - passing revised solution back to Verifier")
        
        return {"solution": solution_text}
    except Exception as e:
        print(f"‚ùå ERROR IN CORRECTOR: {e}")
        print("üö® Corrector failed - terminating workflow")
        print("üí° Possible causes:")
        print(f"   ‚Ä¢ API rate limit exceeded")
        print(f"   ‚Ä¢ Model '{selected_model}' temporarily unavailable")
        print(f"   ‚Ä¢ Network connectivity issues")
        return {"error": f"Failed to correct the solution: {str(e)}"}

# --- 6. Define Conditional Edges ---
# These functions determine the next step in the graph based on the current state.

def decide_after_verification(state: GraphState):
    """
    Determines the next step after the verifier runs.
    - If the solution is correct, end.
    - If there are bugs and iterations are within limit, go to human review.
    - Otherwise, end.
    """
    print("\n" + "üéØ" * 20)
    print("üß† DECISION ENGINE - POST-VERIFICATION ROUTING")
    print("üéØ" * 20)
    print("üìã TASK: Determine next step based on verification results")
    print("\nü§î DECISION LOGIC:")
    print("‚Ä¢ Check if any errors occurred during verification")
    print("‚Ä¢ Analyze verification summary for 'correct' solution")
    print("‚Ä¢ Check iteration count against maximum limit (3)")
    print("‚Ä¢ Route to appropriate next agent or terminate")
    
    print(f"\nüìä CURRENT STATE ANALYSIS:")
    print(f"   Error Status: {state.get('error', 'None')}")
    print(f"   Verification Summary: {state.get('verification_summary', 'N/A')}")
    print(f"   Current Iteration: {state.get('iterations', 0)}/3")
    print(f"   Debug - Summary lowercase: '{state.get('verification_summary', '').lower()}'")
    
    if state.get("error"):
        print("\n‚ùå DECISION: TERMINATE (Error detected)")
        print("üõë Workflow ending due to error condition")
        return "END"

    summary = state.get("verification_summary", "").lower()
    # More flexible checking for correct solutions
    is_correct = (
        "the solution is correct" in summary or
        "solution is correct" in summary or
        summary.strip() == "the solution is correct." or
        "correct" in summary and "incorrect" not in summary and "error" not in summary
    )
    
    if is_correct:
        print("\n‚úÖ DECISION: TERMINATE (Solution accepted)")
        print("üéâ Solution verified as correct - workflow complete!")
        return "END"
    elif state.get("iterations", 0) >= 3: # Set a max of 3 correction loops
        print("\n‚è∞ DECISION: TERMINATE (Max iterations reached)")
        print("üîÑ Maximum correction attempts (3) exceeded")
        return "END"
    else:
        print("\nüîÑ DECISION: CONTINUE (Issues found, within iteration limit)")
        print("üë§ Routing to Human Review for bug report validation")
        return "human_review"

def decide_after_human_review(state: GraphState):
    """
    Determines the next step after human review.
    - If an error was flagged (review rejected), end.
    - Otherwise, proceed to correction.
    """
    print("\n" + "üéØ" * 20)
    print("üß† DECISION ENGINE - POST-HUMAN-REVIEW ROUTING")
    print("üéØ" * 20)
    print("üìã TASK: Route based on human reviewer's decision")
    print("\nü§î DECISION LOGIC:")
    print("‚Ä¢ Check if human reviewer rejected the bug report")
    print("‚Ä¢ If approved, route to Corrector Agent")
    print("‚Ä¢ If rejected, terminate workflow")
    
    print(f"\nüìä HUMAN REVIEW OUTCOME:")
    if state.get("error"):
        print("   Decision: Bug report REJECTED")
        print("\n‚ùå DECISION: TERMINATE (Human reviewer disagreed)")
        print("üõë Workflow ending - human reviewer rejected verifier's findings")
        return "END"
    else:
        print("   Decision: Bug report APPROVED")
        print("\nüîß DECISION: CONTINUE (Proceed with correction)")
        print("üì§ Routing to Corrector Agent for solution refinement")
        return "corrector"

# --- 7. Build the Graph ---
# Connect all the nodes and edges to define the workflow.

workflow = StateGraph(GraphState)

# Add nodes
workflow.add_node("generator", generator_node)
workflow.add_node("self_improvement", self_improvement_node)
workflow.add_node("verifier", verifier_node)
workflow.add_node("human_review", human_review_node)
workflow.add_node("corrector", corrector_node)

# Set entry point
workflow.set_entry_point("generator")

# Add edges - following the paper's pipeline
workflow.add_edge("generator", "self_improvement")  # Step 1 ‚Üí Step 2
workflow.add_edge("self_improvement", "verifier")   # Step 2 ‚Üí Step 3
workflow.add_edge("corrector", "verifier")          # Step 5 ‚Üí Step 3 (loop back)

# Add conditional edges
workflow.add_conditional_edges(
    "verifier",
    decide_after_verification,
    {
        "human_review": "human_review",
        "END": END
    }
)
workflow.add_conditional_edges(
    "human_review",
    decide_after_human_review,
    {
        "corrector": "corrector",
        "END": END
    }
)


# Compile the graph
app = workflow.compile()

def generate_final_report(final_state, initial_state):
    """
    Generate a comprehensive final report showing the entire problem-solving process
    """
    print("\nüìã PROBLEM STATEMENT:")
    print("=" * 60)
    print(initial_state["problem_statement"])
    
    print("\nüîÑ WORKFLOW EXECUTION SUMMARY:")
    print("=" * 60)
    print("‚úÖ Step 1: GENERATOR - Initial solution generated")
    print("‚úÖ Step 2: SELF-IMPROVEMENT - Solution refined and enhanced") 
    print("‚úÖ Step 3: VERIFIER - Solution rigorously verified")
    
    if final_state.get("iterations", 0) > 1:
        print("‚úÖ Step 4: HUMAN REVIEW - Bug reports reviewed")
        print("‚úÖ Step 5: CORRECTOR - Solution corrected based on feedback")
        print(f"üîÑ Total correction iterations: {final_state.get('iterations', 1)}")
    
    print("\nüìä VERIFICATION RESULTS:")
    print("=" * 60)
    verification_status = final_state.get("verification_summary", "N/A")
    print(f"Final Status: {verification_status}")
    
    if final_state.get("bug_report") and "No issues found" not in final_state.get("bug_report", ""):
        print("\nüîç Issues Identified During Process:")
        bug_lines = final_state.get("bug_report", "").split('\n')
        for i, line in enumerate(bug_lines, 1):
            if line.strip():
                print(f"   {i}. {line.strip()}")
    
    print("\nüìà PROCESS METRICS:")
    print("=" * 60)
    print(f"‚Ä¢ Total Iterations: {final_state.get('iterations', 1)}")
    print(f"‚Ä¢ Workflow Status: {'‚úÖ COMPLETED' if not final_state.get('error') else '‚ùå TERMINATED WITH ERROR'}")
    print(f"‚Ä¢ Solution Accepted: {'‚úÖ YES' if 'correct' in verification_status.lower() and 'incorrect' not in verification_status.lower() else '‚ùå NO'}")
    
    print("\n" + "üéâ" * 60)

# --- 8. Run the Workflow ---
if __name__ == "__main__":
    # Example problem statement (IMO 2011, Problem 2)
    default_problem = "Let S be a finite set of at least two points in the plane. Assume that no three points of S are collinear. A windmill is a process that starts with a line l going through a single point P in S. The line rotates clockwise about the pivot P until it first hits another point of S, say Q. This point Q now becomes the new pivot, and the line rotates clockwise about Q until it hits a third point of S. This process continues indefinitely. Show that we can choose a point P in S and a line l through P such that the resulting windmill uses each point of S as a pivot infinitely many times."

    print("Please enter the mathematical problem you would like to solve.")
    print("(Press Enter to use the default IMO windmill problem)")
    print("-" * 40)
    user_problem = input("> ")
    print("-" * 40)

    problem = user_problem.strip() if user_problem.strip() else default_problem
    initial_state = {"problem_statement": problem}

    # Invoke the graph and stream the results
    final_state = {}
    for s in app.stream(initial_state, {"recursion_limit": 10}):
        print("\n" + "="*40)
        node_name = list(s.keys())[0]
        print(f"Node: '{node_name}'")
        print("="*40)
        # The value of the dictionary is the state after the node has run
        final_state = s[node_name]

    print("\n" + "üéâ" * 60)
    print("üèÅ WORKFLOW COMPLETE - IMO PROBLEM SOLVING SUMMARY")
    print("üéâ" * 60)
    
    # Generate comprehensive final report
    generate_final_report(final_state, initial_state)
